"""
This type stub file was generated by pyright.
"""

import builtins
from collections import OrderedDict
from collections.abc import Iterable, Iterator
from typing import Any, Optional, Union
from django.core.cache.backends.base import BaseCache
from redis import Redis
from redis.typing import AbsExpiryT, EncodableT, ExpiryT, KeyT

_main_exceptions = ...
special_re = ...

def glob_escape(s: str) -> str: ...

class DefaultClient:
    def __init__(self, server, params: dict[str, Any], backend: BaseCache) -> None: ...
    def __contains__(self, key: KeyT) -> bool: ...
    def get_next_client_index(self, write: bool = ..., tried: Optional[list[int]] = ...) -> int:
        """
        Return a next index for read client. This function implements a default
        behavior for get a next read client for a replication setup.

        Overwrite this function if you want a specific
        behavior.
        """
        ...

    def get_client(self, write: bool = ..., tried: Optional[list[int]] = ...) -> Redis:
        """
        Method used for obtain a raw redis client.

        This function is used by almost all cache backend
        operations for obtain a native redis client/connection
        instance.
        """
        ...

    def get_client_with_index(
        self, write: bool = ..., tried: Optional[list[int]] = ...
    ) -> tuple[Redis, int]:
        """
        Method used for obtain a raw redis client.

        This function is used by almost all cache backend
        operations for obtain a native redis client/connection
        instance.
        """
        ...

    def connect(self, index: int = ...) -> Redis:
        """
        Given a connection index, returns a new raw redis client/connection
        instance. Index is used for replication setups and indicates that
        connection string should be used. In normal setups, index is 0.
        """
        ...

    def disconnect(self, index: int = ..., client: Optional[Redis] = ...) -> None:
        """
        delegates the connection factory to disconnect the client
        """
        ...

    def set(
        self,
        key: KeyT,
        value: EncodableT,
        timeout: Optional[float] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
        nx: bool = ...,
        xx: bool = ...,
    ) -> bool:
        """
        Persist a value to the cache, and set an optional expiration time.

        Also supports optional nx parameter. If set to True - will use redis
        setnx instead of set.
        """
        ...

    def incr_version(
        self,
        key: KeyT,
        delta: int = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int:
        """
        Adds delta to the cache version for the supplied key. Returns the
        new version.
        """
        ...

    def add(
        self,
        key: KeyT,
        value: EncodableT,
        timeout: Optional[float] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool:
        """
        Add a value to the cache, failing if the key already exists.

        Returns ``True`` if the object was added, ``False`` if not.
        """
        ...

    def get(
        self,
        key: KeyT,
        default: Optional[Any] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> Any:
        """
        Retrieve a value from the cache.

        Returns decoded value if key is found, the default if not.
        """
        ...

    def persist(
        self, key: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> bool: ...
    def expire(
        self,
        key: KeyT,
        timeout: ExpiryT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool: ...
    def pexpire(
        self,
        key: KeyT,
        timeout: ExpiryT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool: ...
    def pexpire_at(
        self,
        key: KeyT,
        when: AbsExpiryT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool:
        """
        Set an expire flag on a ``key`` to ``when``, which can be represented
        as an integer indicating unix time or a Python datetime object.
        """
        ...

    def expire_at(
        self,
        key: KeyT,
        when: AbsExpiryT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool:
        """
        Set an expire flag on a ``key`` to ``when``, which can be represented
        as an integer indicating unix time or a Python datetime object.
        """
        ...

    def lock(
        self,
        key: KeyT,
        version: Optional[int] = ...,
        timeout: Optional[float] = ...,
        sleep: float = ...,
        blocking: bool = ...,
        blocking_timeout: Optional[float] = ...,
        client: Optional[Redis] = ...,
        thread_local: bool = ...,
    ):  # -> Any:
        ...
    def delete(
        self,
        key: KeyT,
        version: Optional[int] = ...,
        prefix: Optional[str] = ...,
        client: Optional[Redis] = ...,
    ) -> int:
        """
        Remove a key from the cache.
        """
        ...

    def delete_pattern(
        self,
        pattern: str,
        version: Optional[int] = ...,
        prefix: Optional[str] = ...,
        client: Optional[Redis] = ...,
        itersize: Optional[int] = ...,
    ) -> int:
        """
        Remove all keys matching pattern.
        """
        ...

    def delete_many(
        self,
        keys: Iterable[KeyT],
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int:
        """
        Remove multiple keys at once.
        """
        ...

    def clear(self, client: Optional[Redis] = ...) -> None:
        """
        Flush all cache keys.
        """
        ...

    def decode(self, value: EncodableT) -> Any:
        """
        Decode the given value.
        """
        ...

    def encode(self, value: EncodableT) -> Union[bytes, int]:
        """
        Encode the given value.
        """
        ...

    def get_many(
        self,
        keys: Iterable[KeyT],
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> OrderedDict:
        """
        Retrieve many keys.
        """
        ...

    def set_many(
        self,
        data: dict[KeyT, EncodableT],
        timeout: Optional[float] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> None:
        """
        Set a bunch of values in the cache at once from a dict of key/value
        pairs. This is much more efficient than calling set() multiple times.

        If timeout is given, that timeout will be used for the key; otherwise
        the default cache timeout will be used.
        """
        ...

    def incr(
        self,
        key: KeyT,
        delta: int = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
        ignore_key_check: bool = ...,
    ) -> int:
        """
        Add delta to value in the cache. If the key does not exist, raise a
        ValueError exception. if ignore_key_check=True then the key will be
        created and set to the delta value by default.
        """
        ...

    def decr(
        self,
        key: KeyT,
        delta: int = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int:
        """
        Decreace delta to value in the cache. If the key does not exist, raise a
        ValueError exception.
        """
        ...

    def ttl(
        self, key: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> Optional[int]:
        """
        Executes TTL redis command and return the "time-to-live" of specified key.
        If key is a non volatile key, it returns None.
        """
        ...

    def pttl(
        self, key: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> Optional[int]:
        """
        Executes PTTL redis command and return the "time-to-live" of specified key.
        If key is a non volatile key, it returns None.
        """
        ...

    def has_key(
        self, key: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> bool:
        """
        Test if key exists.
        """
        ...

    def iter_keys(
        self,
        search: str,
        itersize: Optional[int] = ...,
        client: Optional[Redis] = ...,
        version: Optional[int] = ...,
    ) -> Iterator[str]:
        """
        Same as keys, but uses redis >= 2.8 cursors
        for make memory efficient keys iteration.
        """
        ...

    def keys(
        self, search: str, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> list[Any]:
        """
        Execute KEYS command and return matched results.
        Warning: this can return huge number of results, in
        this case, it strongly recommended use iter_keys
        for it.
        """
        ...

    def make_key(
        self, key: KeyT, version: Optional[int] = ..., prefix: Optional[str] = ...
    ) -> KeyT: ...
    def make_pattern(
        self, pattern: str, version: Optional[int] = ..., prefix: Optional[str] = ...
    ) -> str: ...
    def sadd(
        self,
        key: KeyT,
        *values: Any,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int: ...
    def scard(
        self, key: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> int: ...
    def sdiff(
        self, *keys: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> builtins.set[Any]: ...
    def sdiffstore(
        self,
        dest: KeyT,
        *keys: KeyT,
        version_dest: Optional[int] = ...,
        version_keys: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int: ...
    def sinter(
        self, *keys: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> builtins.set[Any]: ...
    def sinterstore(
        self,
        dest: KeyT,
        *keys: KeyT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int: ...
    def smismember(
        self,
        key: KeyT,
        *members,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> list[bool]: ...
    def sismember(
        self,
        key: KeyT,
        member: Any,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool: ...
    def smembers(
        self, key: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> builtins.set[Any]: ...
    def smove(
        self,
        source: KeyT,
        destination: KeyT,
        member: Any,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool: ...
    def spop(
        self,
        key: KeyT,
        count: Optional[int] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> Union[builtins.set, Any]: ...
    def srandmember(
        self,
        key: KeyT,
        count: Optional[int] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> Union[list, Any]: ...
    def srem(
        self,
        key: KeyT,
        *members: EncodableT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int: ...
    def sscan(
        self,
        key: KeyT,
        match: Optional[str] = ...,
        count: Optional[int] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> builtins.set[Any]: ...
    def sscan_iter(
        self,
        key: KeyT,
        match: Optional[str] = ...,
        count: Optional[int] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> Iterator[Any]: ...
    def sunion(
        self, *keys: KeyT, version: Optional[int] = ..., client: Optional[Redis] = ...
    ) -> builtins.set[Any]: ...
    def sunionstore(
        self,
        destination: Any,
        *keys: KeyT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int: ...
    def close(self) -> None: ...
    def do_close_clients(self) -> None:
        """
        default implementation: Override in custom client
        """
        ...

    def touch(
        self,
        key: KeyT,
        timeout: Optional[float] = ...,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool:
        """
        Sets a new expiration for a key.
        """
        ...

    def hset(
        self,
        name: str,
        key: KeyT,
        value: EncodableT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int:
        """
        Set the value of hash name at key to value.
        Returns the number of fields added to the hash.
        """
        ...

    def hdel(
        self,
        name: str,
        key: KeyT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> int:
        """
        Remove keys from hash name.
        Returns the number of fields deleted from the hash.
        """
        ...

    def hlen(self, name: str, client: Optional[Redis] = ...) -> int:
        """
        Return the number of items in hash name.
        """
        ...

    def hkeys(self, name: str, client: Optional[Redis] = ...) -> list[Any]:
        """
        Return a list of keys in hash name.
        """
        ...

    def hexists(
        self,
        name: str,
        key: KeyT,
        version: Optional[int] = ...,
        client: Optional[Redis] = ...,
    ) -> bool:
        """
        Return True if key exists in hash name, else False.
        """
        ...
